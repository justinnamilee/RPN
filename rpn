#!/usr/bin/perl

# By: Justin Lee
# Date: QUANRANTINE 2020
#
# Description:
#   Yo dawg, this is an RPN calculator.
#   It does that kind of thing, you
#   know?


use strict;



  ######
  #   main::Loader
   #    Terminal IO?

# commands queue
my @command = @ARGV;
# config settings
my %config =
(
	# reverse file input? (mem/rpn mode)
	reverse     => RPN::Constant->DEF_AUTO_REVERSE,
	# you want to talk to me?
	interactive => RPN::Constant->DEF_INTERACTIVE,
);

# init the RPN calculator
RPN->prime;

# parse the input, load files as encountered
for (my $i = 0; $config{interactive} || $i < @command; (!$config{interactive}) && $i++)
{
	my $input = $command[$i];

	if ($config{interactive})
	{
		print q[ ~ ];
		chomp($input = <STDIN>);
	}

	# if we're given files stack their input onto the queue
	if (-f $input)
	{
		if (open(my $fh, q[<], $input))
		{
			my (@c) = ();

			# line parse time
			while (<$fh>)
			{
				chomp;

				s/#.*//; # no comment
				s/^\s+//;
				s/\s+$//;

				if (/^%/ || -f)
				{
					push(@c, $_);
				}
				else
				{
					push(@c, split);
				}
			}

			# excuse me, pardon me; em nodrap, em esucxe?
			splice(@command, $i+1, 0, ($config{reverse} ? reverse(@c) : @c));
		}
		else
		{
			# TODO: add 'ask to continue mode'
			warn qq[Skipping file '$input': $!];
		}
	}
	elsif ($input =~ /^%\s*(.+?)\s*(?:=>\s*(.+))?$/)
	{
		my ($key, $val) = ($1, $2);

		$config{$key} = $val if (defined($val));

		print qq[config:$key> $config{$key}\n];
	}
	else
	{
		RPN::execute($input);
	}
}


exit 0;



################
# SUB PACKAGES #
################ objectify me, daddi


  ######
  #   RPN
   #    The main calculation interface and CPU
   #    control interface, etc.

package RPN;

use strict;

sub FALSE() { 0 }
sub TRUE()  { 1 }

sub bool2num(_)  { shift() ? TRUE : FALSE }
sub force2num(_) { 0 + shift }

my $stack;
my $command;
my $register;
my %operation;
my %help;

# do it!
sub execute
{
	$command = shift;

	if ($command =~ /^(?:\+|-)?(?:0[xXbB])?\d+(?:\.\d+)?(?:e\d+)?$/)
	{
		# push numbers onto the stack
		$stack->push(force2num($command));
	}
	elsif (exists($operation{$command}))
	{
		# grab commands if we have them
		$command = $operation{$command};
	}
	elsif ($command =~ /^help:(.+)/i)
	{
		$command = lc($1);

		if ($command eq q[list])
		{
			print q[list> ]. join(q[, ], keys(%operation)) .qq[\n];
		}
		elsif (exists($help{$command}))
		{
			print qq[help[$command]> $help{$command}\n];
		}
		else
		{
			warn RPN::Error->INPUT_UNKNOWN_CMD;
		}
	}
	elsif ($command =~ /^help/i)
	{
		print qq[help>\n];
		print qq[\t   Get a listing: help:list\n];
		print qq[\tGet command help: help:<command>\n];
	}
	else
	{
		warn RPN::Error->INPUT_UNKNOWN_CMD;
	}

	$command->(@_) if (ref($command));

	undef($command);
}

# init the static crap
sub prime
{
	RPN::Register->prime; # get er' nice and ready
	$register = RPN::Register->init; # control unit
	$stack = $register->frame->top; # calculator stack is always top frame

	%operation =
	(
		# tests
		'=='  => sub { if ($stack->has(2)) { $stack->push(($stack->get(1) == $stack->get(2)) ? TRUE : FALSE) } },
		'!='  => sub { if ($stack->has(2)) { $stack->push(($stack->get(1) == $stack->get(2)) ? FALSE : TRUE) } }, # lol
		'<'   => sub { if ($stack->has(2)) { $stack->push(($stack->get(1)  < $stack->get(2)) ? TRUE : FALSE) } },
		'>'   => sub { if ($stack->has(2)) { $stack->push(($stack->get(1)  > $stack->get(2)) ? TRUE : FALSE) } },
		'<='  => sub { if ($stack->has(2)) { $stack->push(($stack->get(1) <= $stack->get(2)) ? TRUE : FALSE) } },
		'>='  => sub { if ($stack->has(2)) { $stack->push(($stack->get(1) >= $stack->get(2)) ? TRUE : FALSE) } },
		# ternary ops
		'?'   => sub { if ($stack->has(3)) { if ($stack->pop) { my $k = $stack->pop; $stack->set(1, $k) } else { $stack->pop } } },
		# binary ops
		'+'   => sub { if ($stack->has(2)) { $stack->push($stack->pop +  $stack->pop) } }, 
		'/'   => sub { if ($stack->has(2)) { $stack->push($stack->pop /  $stack->pop) } },
		'*'   => sub { if ($stack->has(2)) { $stack->push($stack->pop *  $stack->pop) } },
		'-'   => sub { if ($stack->has(2)) { $stack->push($stack->pop -  $stack->pop) } },
		'%'   => sub { if ($stack->has(2)) { $stack->push($stack->pop %  $stack->pop) } },
		'**'  => sub { if ($stack->has(2)) { $stack->push($stack->pop ** $stack->pop) } },
		'^'   => sub { if ($stack->has(2)) { $stack->push($stack->pop ^  $stack->pop) } },
		'&'   => sub { if ($stack->has(2)) { $stack->push($stack->pop &  $stack->pop) } },
		'|'   => sub { if ($stack->has(2)) { $stack->push($stack->pop |  $stack->pop) } },
		'<<'  => sub { if ($stack->has(2)) { $stack->push($stack->pop << $stack->pop) } },
		'>>'  => sub { if ($stack->has(2)) { $stack->push($stack->pop >> $stack->pop) } }, # vvv safe boolean ops
		'&&'  => sub { if ($stack->has(2)) { my ($a,$b) = ($stack->pop, $stack->pop); $stack->push(bool2num($a && $b)) } },
		'||'  => sub { if ($stack->has(2)) { my ($a,$b) = ($stack->pop, $stack->pop); $stack->push(bool2num($a || $b)) } },
		# unary
		'++'  => sub { if ($stack->has(1)) { $stack->push($stack->pop + 1) } },
		'--'  => sub { if ($stack->has(1)) { $stack->push($stack->pop - 1) } },
		# functions
		pop   => sub { if ($stack->has(1)) { $stack->pop } },
		peek  => sub { if ($stack->has(1)) { print q[peek> ]. $stack->get(1) .qq[\n] } },
		stack => sub { print q[stack#> ]. $stack->size .qq[\n] },
		dump  => sub { my $n = $stack->size; foreach my $s (reverse $stack->dump) { $n--; print qq[stack$n> $s\n]; } },
		flush => sub { $stack->flush }, # toss it all
		empty => sub { $stack->push($stack->empty) },
		load  => sub { $register->load },
		lall  => sub { $register->load while $stack->size > 0 },
		mdmp  => sub { $register->dump },
		step  => sub { $register->step },
		noop  => undef
	);
	%help =
	(
		'=='  => q[Test equality, push result to stack],
		'!='  => q[Test inequality, push result to stack],
		'<'   => q[Test less-than, push result to stack],
		'>'   => q[Test greater-than, push result to stack],
		'<='  => q[Test less-than-equals, push result to stack],
		'>='  => q[Test greater-than-equals, push result to stack],
		'?'   => q[Pop three stack items, push (FIRST ? SECOND : THIRD) to stack],
		'+'   => q[Pop two stack items, add them, push result to stack],
		'/'   => q[Pop two stack items, divide them, push the result to stack],
		'*'   => q[Pop two stack items, multiply them, push the result to stack],
		'-'   => q[Pop two stack items, subtract them, push the result to stack],
		'%'   => q[Pop two stack items, compute (FIRST % SECOND), push the result to the stack],
		'**'  => q[Pop two stack items, exponentiate them, push the result to the stack],
		'^'   => q[Pop two stack items, bitwise-xor them, push the result to the stack],
		'&'   => q[Pop two stack items, bitwise-and them, push the result to the stack],
		'|'   => q[Pop two stack items, bitwise-or them, push the result to the stack],
		'<<'  => q[Pop two stack items, bitwise-shift them left, push the result to the stack],
		'>>'  => q[Pop two stack items, bitwise-shift them right, push the result to the stack],
		'&&'  => q[Pop two stack items, logical-and them, push the result to the stack],
		'||'  => q[Pop two stack items, locical-or them, push the result to the stack],
		'++'  => q[Increment value on top of the stack],
		'--'  => q[Decrement value on top of the stack],
		pop   => q[Pop the stack],
		peek  => q[Peek at the top of the stack],
		stack => q[Show stack information],
		dump  => q[Dump the stack],
		flush => q[Flush the stack completely],
		empty => q[Test if the stack is empty, push the result to stack],
		load  => q[Pop the stack into the next memory location],
		lall  => q[Pop the stack into the next memory location until empty],
		step  => q[Step the register machine],
		noop  => q[NOOOOOOP]
	);
}



  ######
  #   RPN::Stack
   #    A singular stack...What fun is that?

package RPN::Stack;

use strict;

sub init  { my @s = (); return (bless \@s) }
sub has   { my $e = shift->size >= shift; warn RPN::Error->STACK_EMPTY unless $e; return ($e) }
sub dump  { @{shift()} }
sub flush { @{shift()} = () }
sub size  { int(@{shift()}) }
sub empty { not(shift->size) }
sub push  { push(@{shift()}, @_) }
sub pop   { pop(@{shift()}) }
sub set   { shift->[0 - shift] = shift } # reverse indexed
sub get   { shift->[0 - shift] } # ditto
sub top   { shift->get(1) }



  ######
  #   RPN::Stack::Frame
   #    Manages the stacks (even for the calculator).
   #    It will never drop the final frame which is
   #    the RPN calculator's stack.

package RPN::Stack::Frame;

use strict;

sub init  { my @f = (RPN::Stack->init); return (bless \@f) }
sub flush { my $f = shift; $f->pop while ($f->size > 1) }
sub pop   { my $f = shift; pop(@{$f}) if ($f->size > 1) }
sub push  { my $f = shift; push(@{$f}, RPN::Stack->init); return ($f->get) }
sub size  { int(@{shift()}) }
sub get   { shift->[0 - shift] }
sub top   { shift->get(1) }



  ######
  #   RPN::Register
   #    The control unit! Manages memory, registers,
   #    and probably some other important stuff...

package RPN::Register;

use strict;

# super helpers
sub hexify($)  { sprintf(q[0x%016X], shift) }
sub num2reg($) { sprintf(q[R%d], shift) } # note R0 is a special register

# just helpers
sub HIGH32($) { (0xFFFFFFFF00000000 & shift) >> 32 }
sub LOW32($)  { 0x00000000FFFFFFFF & shift }
sub HIGH16($) { (0xFFFF0000 & shift) >> 16 }
sub LOW16($)  { 0x0000FFFF & shift }
sub HIGH8($)  { 0xFF00 & shift }
sub LOW8($)   { (0x00FF & shift) >> 8 }

my %opcode; # static crap
my $run = RPN::Constant->DEF_RUN_STATE;

sub init
{
	my %self =
	(
		register => {}, # machine "registers"
		memory   => {}, # uses a 32-bit address space with bucketed addressing
		frame    => RPN::Stack::Frame->init
	);

	$self{register}->{INSR} = hexify(0);
	$self{register}->{PC} = RPN::Constant->DEF_MEM_BEGIN;
	$self{register}->{RECALL} = RPN::Constant->DEF_MEM_BEGIN;
	$self{register}->{COW} = hexify(0); # don't have a cow, man
	$self{register}->{R0} = hexify(0);

	return (bless \%self);
}

# fetchers
sub register    { shift->{register} }
sub memory      { shift->{memory} }
sub frame       { shift->{frame} }
sub stack       { shift->frame->top }

# read only shaz
sub instruction { hexify(shift->register->{INSR}) }
sub command     { hexify(LOW32(shift->instruction)) }
sub data        { hexify(HIGH32(shift->instruction)) }
sub counter     { hexify(shift->register->{PC}) }
sub next_pc     { hexify(shift->register->{PC}++) }
sub prev_pc     { hexify(shift->register->{PC}--) }

# to and from calculator
sub load        { my $s = shift; $s->memory->{$s->next_pc} = $s->stack->pop }
sub dump
{
	my $s = shift;
	for (my $i = RPN::Constant->DEF_MEM_BEGIN; $i < $s->counter; $i++)
	{
		print q[MEM(]. hexify($i) .q[) => ]. hexify($s->memory->{hexify($i)}) .qq[\n];
	}
}

# these are pretty important
sub run         { shift->step while ($run) }
sub step
{
	my $s = shift;

	if ($s->counter < RPN::Constant::MAX_UINT32)
	{
		$s->register->{INSR} = hexify($s->memory->{$s->next_pc});

		if (exists($opcode{$s->instruction}))
		{
			$opcode{$s->instruction}->(); # run it!
		}
		else
		{
			warn RPN::Error->INPUT_UNKNOWN_CMD;
		}
	}
	else
	{
		warn RPN::Error->MEMORY_LIMIT_REACHED;
	}

	# sleep some amount to simulate clock speeds?
}


# setup the static crap
sub prime
{
	%opcode =
	(
		# low ops (debug, testing, etc)
		hexify(0x000) => sub { $run = 0 }, # halt
		hexify(0x001) => sub { }, # noop
		hexify(0x00A) => sub { print q[REG(INSR) : ]. shift->instruction .qq[\n] }, # what did I just send you?
		hexify(0x00B) => sub { print q[REG(PC)   : ]. shift->counter .qq[\n] },
		hexify(0x00C) => sub { print q[REG(CMD)  : ]. shift->command .qq[\n] }, # should always return 0x00000003
		hexify(0x00D) => sub { print q[REG(DATA) : ]. shift->data .qq[\n] },

		# stack ops
		hexify(0x010) => sub { my $s = shift; $s->memory->{hexify($s->data)} = $s->stack->pop }, # sts
		hexify(0x011) => sub { my $s = shift; $s->stack->push($s->memory->{hexify($s->data)}) }, # lds
		hexify(0x012) => sub { my $s = shift; $s->memory->{hexify($s->register->{PC}++)} = $s->stack->pop }, # stsi
		hexify(0x013) => sub { my $s = shift; $s->stack->push($s->memory->{hexify($s->register->{PC}--)}) }, # ldsd
		hexify(0x014) => sub { my $s = shift; $s->memory->{hexify($s->register->{PC}--)} = $s->stack->pop }, # stsd
		hexify(0x015) => sub { my $s = shift; $s->stack->push($s->memory->{hexify($s->register->{PC}++)}) }, # ldsi
		
		# register ops
		hexify(0x020) => sub { my $s = shift; $s->memory->{hexify($s->data)} = $s->register->{R0} }, # str
		hexify(0x021) => sub { my $s = shift; $s->register->{R0} = $s->memory->{hexify($s->data)} }, # ldr

		# b-b-b-b-b-b-branch
		hexify(0x030) => sub { my $s = shift; $s->register->{PC} = $s->data }, # br
		hexify(0x031) => sub { my $s = shift; }, #jsr => stack frame push, set recall, branch, stack frame pop
	);
}



  ######
  #   RPN::Constant
   #    No more scary constants...Well some.

package RPN::Constant;

use strict;

sub MAX_UINT32()
{ 0xFFFFFFFFFFFFFFFF }
sub MAX_UINT16()
{ 0xFFFFFFFF }
sub MAX_UINT8()
{ 0xFFFF }
sub MIN_UINT32()
{ 0x0000000000000000 }
sub MIN_UINT16()
{ 0x00000000 }
sub MIN_UINT8()
{ 0x0000 }

sub DEF_STACK_BEGIN()
{ 0 }
sub DEF_MEM_BEGIN()
{ 0x0000000000000000 }
sub DEF_AUTO_REVERSE()
{ 1 }
sub DEF_INTERACTIVE()
{ 0 }
sub DEF_RUN_STATE()
{ 0 }



  ######
  #   RPN::Error
   #    A collection of error messages, pure poetry.

package RPN::Error;

use strict;

sub STACK_EMPTY()
{ q[Stack is empty, what are you doing] }
sub INPUT_UNKNOWN_CMD()
{ q[Unknown operation found while parsing input, try reading some documentation first] }
sub POSSIBLE_BUFFER_OVERFLOW()
{ q[Hit unintialized memory, you really suck at this] }
sub MEMORY_LIMIT_REACHED()
{ q[Holy hell, we hit the end of the universe, Bill Gates was wrong after all] }



__END__
